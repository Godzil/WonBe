ワンべぇ: WONBE, WonderWitch BASIC Environment
                                               暫定マニュアル Ver 0.06
                                                         2001年1月29日
                                                      株式会社ピーデー
                                                              川俣　晶
         This software is distributed under GNU General Public License

●これは何か?
　ワンべぇは、WonderWitch上で使用できる小型BASICインタプリタです。
　WonderWitch上ですべての機能が稼働し、シリアルケーブル経由で接続された一般の通信ソフトで操作します。デバッグ済みのプログラムを実行する場合は、シリアルケーブルも通信ソフトも必要ありません。
　WonderWitchのテキスト画面を扱う最小限度のステートメント(cls,locate,print)と、最小限度のボタン入力機能(wait,scan)を持ち、簡易なミニゲームが書けます。
　WonderSwan Color使用時には4色カラーモードが可能です。
　動作テスト用にWin32上で動くバイナリーもありますが、これは、BASIC本体の動作確認用と割り切ってください。
　ドキュメントは、ちょっと見難いかもしれませんが、有志が見やすいものを作ってくれることを期待します。

●必要なもの
・開発時
　WonderWitchのカートリッジとシリアルケーブル。38400bpsの無手順通信が可能な通信ソフトを持つパソコン等。
・実行時
　ワンべぇと実行したプログラムを入れてあるWonderWitchのカートリッジのみ

●準備
・TransMagicなどでワンべぇ(fonbe.fx)をWonderWitchに転送します。
・TransMagicなどの接続を切り、通信ソフトから38400bpsの無手順通信を開始します
・WonderWitch上でワンべぇを実行します
・エントランスメニュー画面でY2を押します
・通信ソフトに、ワンべぇの名前が表示され、"*Ready"と出ます
・これで準備完了です
・print "hello!"リターンと打ってWonderWitchの画面を見てください。文字が出ていれば正常です。

●開発済みプログラムの実行
・WonderWitch上でワンべぇを実行します
・エントランスメニュー画面で実行したいファイルを選んでAボタンを押します

●開発環境の概要
　通常の行番号ベースのエディタが使えます。
　行番号に引き続いて1行を入力してリターンを押すと、プログラムに記録されます。
　行番号だけを入力してリターンを押すとその行は削除されます。
　行番号無しで命令を入力すると即座に実行されます。
　編集はバックスペースによる1文字削除しか使えません。通信ソフトからホスト上のエディタにCOPY&PASTEして、エディタ上で編集してから、通信ソフトに貼り付けてワンべぇに送ると便利です。ただし、フロー制御が無いので、複数行まとめて貼り付けると文字落ちが生じます。張り付けは1行単位で行ってください。プログラムはホスト上で編集してあらかじめTransMagicなどで送信しておくのも有効な手段です。
　現状では2Kバイト以上のプログラムを作成してもsaveコマンドで保存できません。listコマンドを実行してから通信ソフト上でCOPY&PASTEしてホスト上に保存してください。
　実行中は、STARTボタンを押すといつでも対話モードに戻れます。その後、contステートメントで実行を継続できます。
　中間言語に翻訳してから処理するため、中間言語に翻訳できない場合は、入力直後にエラーが出ます。

●言語の概要
　ごく軽いBASIC言語です。
　昔あったTiny BASICに近い構文を持っています。
　データ型は、符号付き16bit整数だけです。
　定数は、-32767〜32767の10進数か、0x0000〜0xffffの16進数で記述できます。-32768は変数には記憶できますが、ソースには書けません。(-32767-1のように書いてください)
　変数は、グローバル変数として、A〜Zのアルファベット大文字1文字のものが26個あります。
　ローカル変数として、a〜zのアルファベット小文字1文字のものが26個あります。ローカル変数はgosubステートメントを実行したときに新しい領域が割り当てられ、returnステートメントを実行したときにgosubする前の領域が戻ってきます。
　配列変数は@(インデックス)という形式の1次元配列だけが使用できます。使用可能なサイズは、プログラム記憶領域(48Kバイト)の残りサイズに等しくなります。インデックスは0から始まります。(例: for i=0 to 9:print @(i):next)
　演算子の優先順位は「単項演算子 > */ > +- > 比較演算子 > and,or,xor」となります。(比較演算子は、<と>と=で記述する演算子すべて)
　計算順序は、括弧()を使って明示的に変更できます。
　オーバーフロー、アンダーフローのチェックはありません。溢れは無視されます。ただしゼロ除算はエラーになります。
　ステートメントなどのキーワードはすべてアルファベット小文字で入力します。大文字を使っても小文字になります。

●　ステートメント一覧

変数 = 式
　式を計算して変数に代入します。letキーワードはサポートしていません。
例: a=b+c

if 式 then ステートメント列
　式が0でなければステートメント列を実行します。0なら次の行から実行を継続します。elseはありません。
例: if (a=0) and (b=1) then goto 200

print [文字列|式|chr(式)][,|;]...
　WonderWitchのテキスト画面の現在のカーソル位置から文字を表示します。
　式の前後に空白文字が入ることはありません。
　chr(式)は、式の値を文字コードと見なして表示します。
　制御コードは扱いませんので、WonderWitchのキャラクタージェネレータにあるすべての文字が表示できます。
　区切り文字の;は何もしません。,はタブストップ位置までカーソルを進めます。
　print文の最後は;または,で終わった場合は改行しません。
例: print "計算結果=",chr(34);1+2;chr(34)

locate 式,式
　WonderWitchのテキスト画面の現在のカーソル位置を設定します。引数はx,yの順番です。
例: locate 10,10

cls
　WonderWitchのテキスト画面を消去します。
例: cls

goto 式
　式の行番号に飛びます。計算型goto文が可能です。つまり、goto A*100とすると、Aが1のきは100行目に。2のときは200行目に飛びます。
例: goto 100

gosub 式
　スタックに現在位置とローカル変数を積んで、式の行番号に飛びます。gotoと同じく計算型gosubが可能です。
　スタックはforと合わせて8レベルまでです。
例: gosub 100

return
　gosubがスタックに積んだ情報を取り出して、そこに処理を戻す。ローカル変数も戻る。
例: return

for 変数=式 to 式
for 変数=式 to 式 step 式
　変数の値を変化させながらnextまで繰り返します。
　最後の変数の値が終値に一致せず、終値+ステップ値がオーバーフローする場合は無限ループする可能性があります。そのような値は指定しないように注意してください。
例: for i=0 to 10 step 2

next
　forステートメントの位置に戻って動作を繰り返します。forステートメントで示した条件が満たされた場合は、nextの次に動作が進みます。nextの後に変数名を書くとエラーになります。
例: next

end
　プログラムの実行を終了します。

break
　その位置で一時的に実行を中断します。contステートメントで実行を継続できます。

rem 文字列
'文字列
　コメントを記述します。後ろに:を置いてステートメントを続けることはできません。
例: rem これはテストプログラムです。
例: 'この式が座標を計算します

new
　メモリ上のプログラムを消去します。

list [行番号][-][行番号]
　指定範囲の行番号のプログラムをリストします。すべて省略すると全行をリストします。

run
run 式
run 文字列
　プログラムを実行します。それに先だって変数やスタックがクリアされます。
　runはメモリ上のプログラムを先頭から。run 式は、式の行番号から。run 文字列は文字列のファイルを読み込んでそれを実行します。
例: run
例: run 100
例: run "test.wb"

cont
　breakステートメントやSTARTボタンによるブレークによって停止した位置から実行を再開します。

save 文字列
　文字列をファイル名としてメモリ上のプログラムを保存します。保存されるのは内部表現ではなくテキスト形式です。
　現在はWonderWitchのファイルシステムの制約上、2Kバイトを超えるファイルを保存できません。listコマンドで端末にリストを送ってそれをCOPY&PASTEして保存してください。
例: save "hello.wb"

load 文字列
　文字列をファイル名としてファイルからプログラムを読み込みます。読み込むのはテキスト形式で、改行はCRLFとLFのどちらでも可です。中間言語に翻訳できない行がある場合はそこで読み込みが中断されます。プログラムの実行中に使用した場合は実行は中断されます。
例: load "hello.wb"

merge 文字列
　メモリ上のプログラムにファイル上のプログラムを混ぜ合わせます。同じ行番号の行は読み込まれる方が優先されます。中間言語に翻訳できない行がある場合はそこで読み込みが中断されます。プログラムの実行中に使用した場合は実行は中断されます。
例: load "merge.wb"

randomize 式
　乱数の初期値を指定します。これを使わないと必ず同じ順序で乱数が発生します。引数には、システム変数tickを指定すると最適です。
例: randomize tick

exit
　ワンべぇを抜けてOSに戻ります。

debug [文字列|式|chr(式)][,|;]...
　printステートメントと同等ですが、WonderWitchの画面ではなく、シリアルポートに送ります。単体で実行する場合には使えないデバッグ専用の機能です。

waitvb 式
　式の回数だけVBLANKを待ちます。待っている間はSTARTボタンによるブレークを受け付けなくなるので、指定できる値は750までと制限されています。750を超える値を指定するとエラーになります。
例: waitvb 75

files
　カレントディレクトリのファイル一覧をシリアルポートに送ります。単体で実行する場合には使えないデバッグ専用の機能です。

play 文字列
　引数の文字列をMMLとして再生します。使用可能にするには「●　playステートメントを有効にする方法」を参照してください。
例: play "cde"

poke 式,式
　最初の式をオフセット、2番目の式を値と見なし、システム変数defsegのセグメントに1バイトのメモリ書き込みを行います。
　Win32版では機能しません。
　注意:csegのセグメントはフラッシュメモリなのでpokeでは書き込めません。

call 式
　式をオフセットと見なし、システム変数defsegのセグメントにマシン語レベルのサブルーチンコール(FAR)を行います。コールする前にシステム変数AX,BX,CX,DX,SI,DI,DS,ESがそれぞれのレジスタに設定されます。リターン後のレジスタ状態はシステム変数AX,BX,CX,DX,SI,DI,ESに保存されます。(注:DSは戻りません)
　Win32版では機能しません。

int 式
　式を割り込み番号と見なし、マシン語レベルのシステム割り込み(int)を行います。WonderWitchのBIOSを呼び出すことができます。コールする前にシステム変数AX,BX,CX,DX,SI,DI,DS,ESがそれぞれのレジスタに設定されます。リターン後のレジスタ状態はシステム変数AX,BX,CX,DX,SI,DI,ESに保存されます。(注:DSは戻りません)
　Win32版では機能しません。

tron
　トレースモードをオンにします。トレースモードに入ると、新しい行の実行始めるごとに、行番号をデバッグコンソールに送信します。

troff
　トレースモードをオフにします。

colormode 式
　カラーモードを設定します。WonderSwan Colorでのみ使用できます。
　式の値は以下の通りです。
0x00  モノクロモード
0x80  4色モード
0xC0  16色モード (設定できますがワンべぇの機能からは描画できません)
0xE0  16色PACKEDモード (設定できますがワンべぇの機能からは描画できません)
　Win32版では機能しません。

color 式,式
　描画する文字の色を指定します。最初の式が前景色のインデックス、2番目の式が背景色のインデックスです。それぞれ、0〜3のみ指定できます。
　実行開始時の初期状態はcolor 3,0に相当する状態です。
　Win32版では機能しません。

palette 式,式,式,式
　パレットを指定します。最初の式が設定するパレットのインデックス(0〜3)を指定します。2番目から4番目の式が、それぞれ、R,G,Bの値を示します。R,G,Bの値はそれぞれ0〜15の範囲内です。
　Win32版では機能しません。
例: palette 0,15,0,0

●　2項演算子
　+ - * / < > = <= >= <> and or xor

●　単項演算子
　- not

●　関数

rnd(式)
　0から式-1までの範囲の乱数を返します。

abs(式)
　式の絶対値を返します。

varptr(変数)
　指定した変数のオフセットを返します。
　Win32版では機能しません。

varseg(変数)
　指定した変数のセグメントを返します。
　Win32版では機能しません。

peek(式)
　式をオフセットと見なし、システム変数defsegのセグメントから1バイトのメモリ読み出しを行います。
　Win32版では機能しません。

●　システム変数 (読み書き可能)

ax,bx,cx,dx,si,di,ds,es
　callおよびintステートメントを使用する際にレジスタの値を指定したり、リターン後のレジスタの値を保存するために使用します。

defseg
　peek関数、poke,callステートメントで使用されるセグメント値を保持します。初期値はdsegの値となります。

●　システム変数 (読み出しのみ)

scan
　WonderSwanのボタンの状態を調べ、1個の整数値として返します。SCAN_で始まるシステム変数とandを取ることで、どのボタンが押されているかどうか判定できます。STARTボタンは実行中断になるので、これは扱えません。

wait
　WonderSwanのボタンが押されるまで待ち、その状態を1個の整数値として返します。SCAN_で始まるシステム変数とandを取ることで、どのボタンが押されたか判定できます。STARTボタンは実行中断になるので、これは扱えません。

scan_a
scan_b
scan_x1
scan_x2
scan_x3
scan_x4
scan_y1
scan_y2
scan_y3
scan_y4
　それぞれのボタンのマスク値を示す定数を返します。
　Aボタンが押されているかどうかを調べるには、下記の例のように記述します。
例: if scan and scna_a then print "Aボタンが押さている"

tick
　システムタイマーのtickを返します。ただし、本来のtick値は符号無し32bit整数であり、ここで得られるのは16bit符号あり整数であることに注意が必要です。はみ出たbitは捨てられます。

dseg
　実行中のDSセグメントレジスタの値を返します。変数やワンべぇプログラムの中間言語コードはすべてこのセグメントにあります。
　Win32版では機能しません。

cseg
　実行中のCSセグメントレジスタの値を返します。ワンべぇのプログラム本体がこのセグメントにあります。
　Win32版では機能しません。

sseg
　実行中のSSセグメントレジスタの値を返します。マシン語スタックがこのセグメントにあります。
　Win32版では機能しません。

hardarch
　現在実行中のWonderSwanがColorモデルかどうかを返します。モノクロWonderSwanなら0。WonderSwan Colorなら1になります。
　Win32版では機能しません。

●　ファイル保存時の拡張子
　ワンべぇのソースフィルは、".wb"で終わるファイル名にしておいて下さい。loadなどのコマンドでは拡張子に関係なく読み込めますが、エントランスメニューに表示されるのは".wb"で終わるファイル名だけです。

●　playステートメントを有効にする方法
　sound.ilを、/rom0に転送しておいてください。このファイルが無いとplayステートメントを使用しても音が出ません。sound.ilが無ければ音が出ないだけで、プログラムは実行されます。
　Win32版では、クジラ飛行机さん作の"テキスト音楽「サクラ」"に含まれるdsakura.dllを用いてMMLを再生することができます。このソフトは、http://www.text2music.com/より入手できます。dsakura.dllは環境変数pathの通ったディレクトリならどこに置いても構いません。必要ファイルはこのDLLのみです。dsakura.dllが無ければ音が出ないだけで、プログラムは実行されます。ただし、MMLの仕様が完全に同じではないことに注意してください。なお、Win32版ではplayステートメント実行時にカレントディレクトリに$$$.midというファイルを生成します。実行終了後には削除して構いません。

●　配布規則
　このバージョンより、本ソフトは、GNU General Public License (GPL)に従うものとしました。詳細はhttp://www.gnu.org/にあります。
　要するに、誰でも、どんな目的にも使用して良いということです。ただし、本ソフトを売ってはいけません。また、ソースコードは必ず公開しなければなりません。商品の中に収録することは可ですが、本ソフトを利用者が自由にコピーして配布することを妨げてはなりません。
　2000年12月現在、ソースコードは株式会社ピーデーの川俣晶(autumn@piedey.co.jp)が管理しています。有益なソースコードの修正をフィードバックしてくれれば、こちらのソースツリーに反映します。

●　余談
　ワンべぇは、私こと川俣が、20世紀への感謝と決別の気持ちで作ったものです。つまり、私にとって、マイコン/パソコンに出会ったという事件こそが、20世紀最大のイベントであり、そこで大きな役割を果たした超小型インタプリタ言語達、Tiny BASIC、VTL、GAME、TL/1は大きな印象を私の中に残したのです。そして、当時、私はプログラム言語を自分で作りたくて、一生懸命研究を重ねていたのも、また事実です。結局、いくつものトイ言語を開発しました。必要とあれば実用言語も作りました。ENIXのTOKYOナンパストリートをFM-7からPC-8801に移植するときにはメモリ効率を上げるために整数型の小型インタプリタを作ったりもしました。しかし、最終的に構造化アセンブラの匂いを微かに含んだ自作のZ-80用アセンブラ開発システムAZASをもって自作言語の世界は終着駅を迎えたわけです。この時点で、明らかに、Tiny BASICのような言語を開発する意味がなかったのです。必要な性能を得るためには、アセンブラレベルの開発が不可欠だったためです。作ることはできたけれど、作る意味は既に無かったのです。そして、時代が16bitの時代に移ると共に、私も自作言語を使うのはやめて、出来の良い既存の処理系を使うようになりました。MASM　1.27〜, Turbo Pascal 3.0, Turbo C 1.5〜2.0, MS-C 6.0〜, Visual BASIC 1.0〜, JDK 1.02〜などなど。しかし、ふと20世紀も終わる頃に振り返ると、右も左も分からない少年時代に憧れたあのシンプルなTiny BASICが思い出されたわけです。だから、これこそが私にとっての20世紀そのもの、という気持ちを込めて作ったのです。
　そのような訳で、これにはある種の世代性があります。BASICでゲームを作るというと、MSXとかベーマガという世代もいるようですが、はっきり言って、この世代にはワンべぇは理解できないと思います。MSXに搭載されたBASICは、超高機能巨大BASICであって、Tiny BASICとはまったく世代が違うのです。PC-8801やFM-7まで遡れる世代でも、まだ分からないでしょう。結局のところ、これが分かるためには、パソコンがパソコンと呼ばれる前、マイコンと呼ばれ、ケースに収まっておらず基板が剥き出しの状態で売られていた時代まで遡る必要があります。つまりは、そういう時代、何かを得ようとすれば手作りの要素が入り込んで当たり前の時代のロマンへ捧げるものが、このワンべぇと言うことになります。そして、そのロマンを再現するにふさわしい土台として、WonderWitchという製品がこの時代に登場したことも、不思議な縁だと思います。
　というわけで、私がワンべぇ利用者に言いたいことは一つです。このロマンを分かち合ってくれ。つまり、気に入らないところは、どんどん改造してくれ。好き勝手に改造して使えることを保証するために、ソースはGPLにしてあります。

●　同梱ワンべぇプログラム
▼デモ
colordemo.wb
　カラー機能のデモ (これのみWonderSwanColor用)
▼ゲーム
ctb.wb
　落ち物ゲーム
janken.wb
　ジャンケンゲーム
shoot.wb
　シューティングゲーム
star.wb
　STAR TREK風ゲーム"STAR WITCH" (同梱star.txt参照)
　プログラムの書き方の参考にどうぞ
▼テスト
test.wb
　簡単なインタプリタの動作テスト
testcall.wb
　callステートメントの動作テスト
testcont.wb
　contステートメントの動作テスト
testfor.wb
　forステートメントの動作テスト
testgosub.wb
　gosubステートメントの動作テスト
testif.wb
　ifステートメントの動作テスト
testint.wb
　intステートメントの動作テスト
testlocate.wb
　locateステートメントの動作テスト
testlongloop.wb
　STARTキーによる中断のテスト
testpeekpoke.wb
　peek関数pokeステートメントのテスト

●　変更履歴

2001年1月29日 Ver 0.06
・WonderSwan Colorの開発キットに移行
・colormode, palette, colorステートメント、hardarchシステム変数を追加
・ドキュメントに余談を追加

2000年12月10日 Ver 0.05
・Hirotaka JOE Ohkuboさんの差分(0.04j4)をマージ play文が使用可能に (要sound.il)
・?をキーワードdebugと見なす
・then直後が10進整数値ならgotoの省略を許す
・マシン語関連機能の追加
・tron/troffコマンドの追加(実行行番号の表示)

2000年11月12日 Ver 0.04
・13など0x0dを含む行番号を削除しようとするとプログラムが壊れたバグを取った
・処理系をTurbo C2.0からVisual C++ 1.51に変更
・ロード速度を大幅に改善
・エントランスメニューは.wbのみ表示
・サンプルゲームSTAR WITCH(star.wb, star.txt)を添付

2000年11月7日 Ver 0.03
・演算子の優先順位 単項演算子 > */ > +- > 比較演算子 > and,or,xor
・比較演算子成立時の値を1から-1に変更
・プロンプトをOKに変更
・print/debugで負数が正数として出力されていたバグを解消
・forの終値がピッタリ一致しなくてもnextでループ脱出するように変更
2000年11月7日 Ver 0.02 scan_XXが機能しないバグを取った
2000年11月6日 Ver 0.01 最初のバージョン

●　問い合わせ先
株式会社ピーデー http://www.piedey.co.jp/
川俣　晶 autumn@piedey.co.jp

以上
